with container.ArrayBuffer

/**
 * tests correctness of return/break/continue cross edges with finally blocks
 *
 * @note to self: I don't see why catch would be an issue, but finally is
 */
type mar:

type def init {
  var arr = new ArrayBuffer[String]

  arr += "möp"
  arr += "count"
  arr += ""
  arr += "☢"

  arr
}

type def bytes(s : String, b : Block[bool]) : int
  = (s.bytes().count _ do {b.eval()}).sign().resize[32]()

type def chars(s : String, b : Block[bool]) : int
  = (s.chars().count _ do {b.eval()}).sign().resize[32]()

test "simple chars" {
  var arr = init()

  9 == (arr.iterator().fold[int](0) s,v do {
    s + (v.chars().count _ do {v.size() < 15U}).sign().resize[32]()
  })
}

test "simple bytes" {
  var arr = init()

  12 == (arr.iterator().fold[int](0) s,v do {
    s + (v.bytes().count _ do {v.size() < 15U}).sign().resize[32]()
  })
}

test "nested call both bytes" {
  var arr = init()

  12 == (arr.iterator().fold[int](0) s,v do {
    do {
      s + bytes(v, {break bytes(v, true)}) + chars(v, {break chars(v, true)})
    } while false
  })
}

test "nested call both chars" {
  var arr = init()

  9 == (arr.iterator().fold[int](0) s,v do {
    do {
      s + bytes(v, {0 != bytes(v, true)}) + chars(v, {break chars(v, true)})
    } while false
  })
}

test "fold fold chars" {
  var arr = init()

  9 == (arr.iterator().fold[int](0) s,v do {
    s + (v.chars().fold[int](0) s,v do {++s})
  })
}

test "fold fold bytes" {
  var arr = init()

  12 == (arr.iterator().fold[int](0) s,v do {
    s + (v.bytes().fold[int](0) s,v do {++s})
  })
}

test "fold fold both" {
  var arr = init()

  21 == (arr.iterator().fold[int](0) s,v do {
    s +
    (v.bytes().fold[int](0) s,v do {++s}) +
    (v.chars().fold[int](0) s,v do {++s})
  })
}

test "count stateful mixed" {
  // rebuild the complex fold tests with counts and a local variable
  false
}

test "foreach stateful mixed" {
  // rebuild the complex fold tests with foreach and a local variable
  false
}