with range := container.range.apply

/**
 * tests that intearleave value and void cross edges
 */
type mar:

type def outer(v : int, n : int, b : Block[int]) = f(v, n, b)
type def f(v : int, n : int, b : Block[int]) {
  var i = 0;
  do {
    i = inner(v, break)
    range(0,n).foreach _ do (i += b.eval())
  } while false
  i
}

type def inner(n : int, b : Block[int]) = g(n, b)
type def g(n : int, b : Block[int]) {
  var i = 0
  range(0,n).foreach _ do (i += b.eval())
  i
}

test "call" {
  1 == outer(1, 7, 1)
}

test "cross" {
  5 == {
    do {
      outer(1, 5, break 2)
      5
    } while false
  }
}

test "single" {
  true && 5 == {
    do {
      outer(1, 7, break 2)
      5
    } while false
  }
}

test "double" {
  true && true && 5 == {
    do {
      outer(1, 7, break 2)
      5
    } while false
  }
}

test "call 0" {
  7 == outer(0, 7, 1)
}

test "cross 0" {
  2 == {
    do {
      outer(0, 5, break 2)
      5
    } while false
  }
}

test "single 0" {
  true && 2 == {
    do {
      outer(0, 7, break 2)
      5
    } while false
  }
}

test "double 0" {
  true && true && 2 == {
    do {
      outer(0, 7, break 2)
      5
    } while false
  }
}