/**
 * Let substitutions intearleave their returns to ensure that they are tracked
 * correctly.
 */
public type mar:

public type def ite(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = if g.eval() tb.eval() else eb.eval()

public type def n(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = ite(g.eval(), ite(g, tb, {return false}), ite(g, {return false}, eb))

public type def pt(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = ite(g.eval(), ite(g, tb, {return false}), eb.eval())

public type def pe(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = ite(g.eval(), tb.eval(), ite(g, {return false}, eb))

public type def et(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = ite(g.eval(), ite(g, tb, eb.eval()), eb.eval())

public type def ee(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = ite(g.eval(), tb.eval(), ite(g, tb.eval(), eb))

test "use" {
  ite(true, true, false)
}
test "use2" {
  !ite(false, true, false)
}

test "n" {
  n(true, true, false)
}

test "n2" {
  n(n(true, true, false), n(false, false, true), n(false, false, false))
}

test "pt" {
  pt(true, true, false)
}

test "pe" {
  pe(true, true, false)
}

test "et" {
  et(true, true, false)
}

test "ee" {
  ee(true, true, false)
}

type def nested(g : Block[bool])
  = n(pe(g, true, g), pt(g, {return true}, {return true}), ee(g, {return g.eval()}, g))

test "nested t" {
  nested(true)
}

test "nested f" {
  !nested(false)
}

test "nested t re" {
  true && nested(true)
}

test "nested f re" {
  true && !nested(false)
}


test "nesting" {
  // the idea of this test was to check translation with deeper nesting but I
  // didn't get there yet
  // note: a very impartant test would be local/ext nested ite reapply, i.e.
  // packaging essentially all the helper functions above into a single test
  // expression by manually inlining until ite calls
  false
}

test "todo" {
  // obviously, only ite should use if
  // since I found some issues with this version, keep it and add the intended
  // variant in another test (check for ext variants)
  false
}