/**
 * Let substitutions intearleave their returns to ensure that they are tracked
 * correctly.
 *
 * @note  this test creates an insane amount of temporary blocks; if BAs are
 *   eliminated correctly, almost all of these blocks can be deleted again
 */
public type mar:

public type def ite(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = if g.eval() tb.eval() else eb.eval()

public type def n(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = ite(g.eval(), ite(g, tb, {return false}), ite(g, {return false}, eb))

public type def pt(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = ite(g.eval(), ite(g, tb, {return false}), eb.eval())

public type def pe(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = ite(g.eval(), tb.eval(), ite(g, {return false}, eb))

public type def et(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = ite(g.eval(), ite(g, tb, eb.eval()), eb.eval())

public type def ee(g : Block[bool], tb : Block[bool], eb : Block[bool])
  = ite(g.eval(), tb.eval(), ite(g, tb.eval(), eb))

test "use" <: provable {
  ite(true, true, false)
}
test "use2" <: provable {
  !ite(false, true, false)
}

test "n" <: provable {
  n(true, true, false)
}

test "n2" <: provable {
  n(n(true, true, false), n(false, false, true), n(false, false, false))
}

test "pt" <: provable {
  pt(true, true, false)
}

test "pe" <: provable {
  pe(true, true, false)
}

test "et" <: provable {
  et(true, true, false)
}

test "ee" <: provable {
  ee(true, true, false)
}

public type def nested(g : Block[bool])
  = n(pe(g, true, g), pt(g, {return true}, {return true}), ee(g, {return g.eval()}, g))

test "nested t" <: provable {
  nested(true)
}

test "nested f" <: provable {
  !nested(false)
}

test "nested t re" <: provable {
  true && nested(true)
}

test "nested f re" <: provable {
  true && !nested(false)
}

// note: even at this depth, the code creates ~70k blocks with the current rules
public type def deep(g : Block[bool])
  = n(pe(g, true, !g.eval()),
      pt(g,
        et(!g.eval(),
            pt(g, {return true}, {return false}),
            g
          ),
        false),
    {return g.eval()})

test "deep t" <: provable {
  deep(true)
}

test "deep f" <: provable {
  !deep(false)
}

test "deep t re" <: provable {
  true && deep(true)
}

test "deep f re" <: provable {
  true && !deep(false)
}

// note: this test creates ~80k blocks, but it is imortant wrt. ordering and
// implicits
test "deep mut" <: provable {
  var r = true
  r && deep(r) && {!(r = false)} && !deep(r) && !r
}