with range := container.range.apply

/**
 * tests that a chi with a single argument survives; we achieve it by not using
 * the paramater at all
 *
 * @note  requires manual inspection until we have π-rebind
 *
 * @note  with the current implementation, only the T tests have singular chis
 */
class T {
  def outer(n : int, b : Block[int]) = f(n, b)
  def f(n : int, b : Block[int]) {
    var i = 0
    range(0,n).foreach _ do (i += 1)
    i
  }
}

class S <: T {
  // note: as of Tyr 0.8, there is no π-rebind, so T.outer needs to be
  // overridden explicitly if it should call S.f
  override
  def outer(n : int, b : Block[int]) = f(n, b)

  // same effect, but uses eval twice
  override
  def f(n : int, b : Block[int]) {
    switch n {
      if 0 0
      if 1 b.eval()
      else {
        var i = 0
        range(0,n).foreach _ do (i += b.eval())
        i
      }
    }
  }
}

type regular {
  test "call S" {
    val x = new S
    let r = x.outer(7,1)
    delete x
    7 == r
  }
  test "call T" {
    val x = new T
    let r = x.outer(7,1)
    delete x
    7 == r
  }
}

type cross {
  test "call S" {
    val x = new S
    try {
      1 == {
        do {
          x.outer(7, break 1)
          5
        } while false
      }
    } finally delete x
  }
  test "call T" {
    val x = new T
    try {
      5 == {
        do {
          x.outer(7, break 1)
          5
        } while false
      }
    } finally delete x
  }
}

type rebind {
  test "call S" {
    val x = new S
    try {
      true && 1 == {
        do {
          x.outer(7, break 1)
          5
        } while false
      }
    } finally delete x
  }
  test "call T" {
    val x = new T
    try {
      true && 5 == {
        do {
          x.outer(7, break 1)
          5
        } while false
      }
    } finally delete x
  }

  test "double S" {
    val x = new S
    try {
      true && true && 1 == {
        do {
          x.outer(7, break 1)
          5
        } while false
      }
    } finally delete x
  }
  test "double T" {
    val x = new T
    try {
      true && true && 5 == {
        do {
          x.outer(7, break 1)
          5
        } while false
      }
    } finally delete x
  }
}