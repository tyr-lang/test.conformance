with exceptions.NullAccess
with exceptions.SegFault
with ext := test.tryCatchBoundCatchMixedNested.mar
with ext.base

/**
 * tests local throw optimization with bind and rebind
 */
public type mar:

test "use" <: provable {
  base({}, {}, {})
}

type def both(b : Block[bool]) : bool {
  b.eval() && {try {
      base({}, {throw new SegFault}, {throw new NullAccess})
    } catch e {
      // use NA to signal skip a
      if NullAccess {
        delete e
        return true
      }
      else {
        delete e
      }
    }
    false
  }
}

type def reverse(b : Block[bool]) : bool {
  b.eval() && {
    base({}, {throw new NullAccess}, {throw new SegFault})
    true
  }
}

type def immediate(b : Block[bool]) : bool {
  b.eval() && {try {
      base({throw new NullAccess}, {return false}, {return false})
    } catch e {
      // use NA to signal skip a
      if NullAccess {
        delete e
        return true
      }
      else {
        delete e
      }
    }
    false
  }
}

test "both" <: provable {
  both(true)
}

test "reverse" <: provable {
  reverse(true)
}

test "immediate" <: provable {
  immediate(true)
}

test "both rebind" <: provable {
  true && both(true)
}

test "reverse rebind" <: provable {
  true && reverse(true)
}

test "immediate rebind" <: provable {
  true && immediate(true)
}

test "both drop" <: provable {
  !both(false)
}

test "reverse drop" <: provable {
  !reverse(false)
}

test "immediate drop" <: provable {
  !immediate(false)
}

test "ext both" <: provable {
  ext.both(true)
}

test "ext reverse" <: provable {
  ext.reverse(true)
}

test "ext immediate" <: provable {
  ext.immediate(true)
}

test "ext both rebind" <: provable {
  true && ext.both(true)
}

test "ext reverse rebind" <: provable {
  true && ext.reverse(true)
}

test "ext immediate rebind" <: provable {
  true && ext.immediate(true)
}

test "ext both drop" <: provable {
  !ext.both(false)
}

test "ext reverse drop" <: provable {
  !ext.reverse(false)
}

test "ext immediate drop" <: provable {
  !ext.immediate(false)
}