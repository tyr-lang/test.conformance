/**
 * Test flat Ref[T].
 */
type T {

  test "instance" <: noCompile {
    val p : Ref[int]
  }

  test "ref zero/null" <: noCompile {
    val p : Ref[int] = 0
  }

  test "sane instance" {
    var i : int = 0
    val p : Ref[int] = i
  }

  test "usage" {
    var i : int = 0
    val p : Ref[int] = i
    i = 1
    p == 1
  }

  test "usage 2" {
    var i : int = 0
    val p : Ref[int] = i
    p = 1
    i == 1
  }

  test "compare" {
    var i : int = 0
    val p : Ref[int] = i
    i = 1
    p == p
  }

  test "assymetric compare" {
    var i : int = 0
    val p : Ref[int] = i
    i = 1
    i == p
  }

  test "usage type block" {
    var i : int = 0
    /*val p : Ref[{int}] = i
    i = 1
    p == 1 */
    false // currently broken, try again when implementing CT in 0.7
  }

  test "advanced type block" {
    var i : int = 0
    /*val p : Ref[{
      Seq(any, int, Integer[32]).reduce(any) l,r do (Type.join(l,r))
    }] = i
    i = 1
    p == 1 */
    false // currently broken, try again when implementing CT in 0.7
  }
}
