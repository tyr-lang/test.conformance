/**
 * the super type of all pointers; basically C's "void*"
 *
 * @note in contrast to C, C++ and Java, arbitrary pointers do not have a null.
 *       This is because some pointer-like types such as ref do not have a null.
 *
 * @note Arbitrary pointer values may not be observable. Therefore, they do not
 *       offer any operators.
 *
 * @note Non-observable pointers may still alias.
 *
 * @author Timm Felden
 */
type pointer <: any, native;

/**
 * An observable pointer that can be observed by regular code in the form of
 * equivalence.
 *
 * @author Timm Felden
 */
type observablePointer <: pointer {

  /* flat value comparison. Can also be used if this == null */
  def != (v : observablePointer) : bool <: native, operator.precedence[80];

  /* flat value comparison. Can also be used if this == null */
  def == (v : observablePointer) : bool <: native, operator.precedence[80];
}

/**
 * A reference to a T; basically C++'s &T. Ref is used to type this in object
 * functions. A Ref cannot be null.
 *
 * @note Ref[T] is a native type, as its representation is T* instead of i8*
 *
 * @note "var x : T" creates a value x of type Ref[T] plus some memory to be modified
 *
 * @todo Creation of references requires some sort of checking.
 * Otherwise, a reference could be abused to manipulate immutable and even
 * inexistent values.
 *
 * @note T cannot be covariant, it is the promised minimal content pointed to.
 */
type Ref[T : Type] <: pointer, proxy[T], joinImplicit, native {

  /**
   * Implicit dereference allow value types to be used by reference.
   */
  def implicit : T <: native;

  /** 
   * Assign a value to the target of this reference. I.e. the location pointed
   * to by this will be overwritten by v.
   *
   * @todo The correct result type would be v.this.type
   */
  def `=` (v : T) : T
          <: native, operator.precedence[20], operator.rightAssociative;
}
